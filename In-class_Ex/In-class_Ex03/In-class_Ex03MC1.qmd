---
title: "In-class Exercise 3"
author: "Belinda Lim"
date: May 17, 2025
date-modified: "last-modified"
format:
  html:
    theme: flatly
    toc: true
editor: source
execute:
  eval: true
  echo: true
  warning: false
  freeze: true
---

# **1Â  Mini-Challenge 1**

## **1.1 Load packages**

In the code chunk below, p_load() of pacman packages is used to load the R packages into R environment: 
```{r}
pacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph)
```

## **1.2 Importing Data**

in the code chunk below, 'fromJSON()' of 

```{r}
kg <- fromJSON("MC1/data/MC1_graph.json")
```

### Inspect Structure
```{r}
str(kg, max.level = 1)
```
### Extract and Inspect

```{r}
nodes_tbl <-as_tibble(kg$nodes)
edges_tbl <-as_tibble(kg$links)
```

## **1.3 Initiate EDA**

```{r}
ggplot(data = edges_tbl,
       aes(y = `Edge Type`)) +
  geom_bar()
```

```{r}
ggplot(data = nodes_tbl,
       aes(y = `Node Type`)) +
  geom_bar()
```
## **1.4 Create Knowledge Graph**

### Step 1: Mapping from node id to row index

```{r}
id_map <- tibble(id = nodes_tbl$id,
                 index = seq_len(
                   nrow(nodes_tbl)))
```

This ensures each id from your node list is mapped to the correct row number.

### Step 2: Map source and target IDs to row indices

```{r}
edges_tbl <- edges_tbl %>%
  left_join(id_map, by = c("source" = "id")) %>%
  rename(from = index) %>%
  left_join(id_map, by = c("target" = "id")) %>%
  rename(to = index)
```

### Step 3: Filter out any unmatched (invalid) edges
```{r}
edges_tbl <- edges_tbl %>%
  filter(!is.na(from), !is.na(to))
```

### Step 4: Creating the graph

Lastly 
```{r}
graph <- tbl_graph(nodes = nodes_tbl, edges = edges_tbl, directed = kg$directed)
                  
```

## **1.5 Visualising the knowledge graph**
```{r}
set.seed(1234)
                  
```

## **1.6 Visualising the whole graph**
```{r, eval = FALSE}
ggraph(graph, layout = "fr") +
  geom_edge_link(alpha = 0.3, colour = "gray") + 
  geom_node_point(aes(color = `Node Type`),
                  size = 4) +
  geom_node_text(aes(label = name), repel = TRUE, size = 2.5) + #repel will force word apart
  theme_void()
```
### Visualising the sub-graph

#### Step 1: Filter edges to only "MemberOf"

```{r}
graph_memberof <-graph %>%
  activate(edges) %>%
  filter(`Edge Type` == "MemberOf")  #filter away the edge, nodes are still there (orphan)
```

#### Step 2: Extract only connected nodes (i.e., used in these edges)

```{r}
used_node_indices <- graph_memberof %>%  #eliminate away orphan nodes
  activate(edges) %>%
  as_tibble() %>%
  select(from, to) %>%
  unlist() %>%
  unique()
```

#### Step 3: Extract only connected nodes (i.e., used in these edges)

```{r}
graph_memberof <- graph_memberof %>%
  activate(nodes) %>%
  mutate(row_id = row_number()) %>%
  filter(row_id %in% used_node_indices) %>%
  select(-row_id) # optional clean up
```

#### Plot the sub-graph

```{r}
ggraph(graph_memberof, layout = "fr") +
  geom_edge_link(alpha = 0.5, colour = "gray") + 
  geom_node_point(aes(color= `Node Type`),
                  size = 1) + 
  geom_node_text(aes(label = name),
                 repel = TRUE,
                 size = 2.5) + 
  theme_void()
#they stay with their group for quite long
# change to interactive so that can hover and see all labels
```




```{r}


```
